#pragma once

#include <unordered_map>
#include <filesystem>
#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include "SDL2/SDL.h"
#include "SDL2/SDL_image.h"
#include <format>
#include "log.hpp"
#include "globals.hpp"
#include "utilities.hpp"

namespace Core{

  inline std::filesystem::path map_folder = "maps_info";
  inline std::filesystem::path img_folder = "Images";
  inline std::filesystem::path tiles_folder = "Tiles";
  inline std::filesystem::path tiles_file = tiles_folder/"tiles.txt";

  class Manager{
  public:
    Manager();
    ~Manager();

    inline std::filesystem::path get_file(const std::string& key);
    inline void add_file(const std::string& key, const std::filesystem::path& filename);
    inline void replace_file(const std::string& key, const std::filesystem::path& filename);
    inline bool haskey_file(const std::string& key){return m_files.find(key) != m_files.end();}
    inline bool haskey_texture(const std::string& key){return m_textures.find(key) != m_textures.end();}
    
    inline void remove_file(const std::string& key);
    inline SDL_Texture* get_texture(const std::string& key);

    /*
     * void Manager::add(const std::string& key, SDL_Texture* t)
     * template<class T>
     * void Manager::add(const std::string& key, SDL_Surface* s, T& window,)
     * template <class T>
     * void Manager::add(const std::string& key, const std::string& filename,T& window)
     *
     * Adds a texture to the texture manager.
     * If `key` already exists prints an error message and abort;
     * If a surface is passed, it has to be freed manually.
     *
     * `T& window`  must be a (smart) pointer to a window instance
     */
    inline void add_texture(const std::string& key, SDL_Texture* t);
    template<class T>
    inline void add_texture(const std::string& key, SDL_Surface* s, T& window);
    template <class T>
    inline void add_texture(const std::string& key, const std::filesystem::path& filename,T& window);
    /*
     * void replace(const std::string& key, SDL_Texture* t);
     * template <class T>
     * void replace(const std::string& key, SDL_Surface* s, T& window);
     * template <class T>
     * void replace(const std::string& key, const std::string& filename, T& window);
     *
     * replace the texture corresponding to `key`. If `key` does not exitst, it adds the texture
     *
     * `T& window` must be a (smart) pointer to a window instance
     */
    inline void replace_texture(const std::string& key, SDL_Texture* t);
    template <class T>
    inline void replace_texture(const std::string& key, SDL_Surface* s, T& window);
    template <class T>
    inline void replace_texture(const std::string& key, const std::filesystem::path& filename, T& window);

  private:
    std::unordered_map<std::string,std::filesystem::path> m_files;
    std::unordered_map<std::string,SDL_Texture*> m_textures;

    /*
     *  void _add(const std::string& key, SDL_Texture* t);
     *
     *  Adds a texture without checking if 'key' already exists.
     *
     */
    inline void _add(const std::string& key, SDL_Texture* t);
  };

  inline Manager::Manager(){
    m_files[g_AM] = map_folder /"Ancient_mediterranean.txt";
  }

  inline Manager::~Manager(){
    for(auto [key,val] : m_textures)
      SDL_DestroyTexture(val);
  }

  inline void Manager::add_file(const std::string& key, const std::filesystem::path& filename){
    if(haskey_file(key)){
      LOGL("Resource Manager error: file {} already exist, cannot override",key);
      return;
    }
    if(!std::filesystem::is_regular_file(filename)){
      LOGL("Resource Manager error: file {} not found: cannot save",filename.string());
      return;
    }
    m_files[key] = filename;
    LOGL("[Resorce Manager] file {} added", filename.string());
  }

  inline void Manager::replace_file(const std::string& key, const std::filesystem::path& filename){
    if(!std::filesystem::is_regular_file(filename)){
      LOGL("Resource Manager error: file {} not found: cannot save",filename.string());
      return;
    }
    m_files[key]=filename;
    LOGL("[Resorce Manager] file {} added", filename.string());

  }

  inline void Manager::remove_file(const std::string& key){
    if(!haskey_file(key))
      return;
    auto it = m_files.find(key);
    m_files.erase(it);
    LOGL("[Resource Manger]: removed file  at key {} ", key);
  }


  inline std::filesystem::path Manager::get_file(const std::string& key){
    if (!haskey_file(key)) {
      LOGL("[Resource Manager]: file {} is not in resource manager", key);
      exit(EXIT_FAILURE);
    }
    return m_files.at(key);
  }

  inline SDL_Texture* Manager::get_texture(const std::string& key){
    if (!haskey_texture(key)) {
      LOGL("[Resource Manager]: texture {} is not in resource manager",key);
      exit(EXIT_FAILURE);
    }
    return m_textures.at(key);
  }


  inline void Manager::add_texture(const std::string& key, SDL_Texture* t){
    if (haskey_texture(key)) {
      LOGL("[Resource Manager]: texture {} already exists. Aborting",key);
      exit(EXIT_FAILURE);
    }
    m_textures[key] = t;
  }

  inline void Manager::_add(const std::string& key, SDL_Texture* t){
    m_textures[key] = t;
  }

  template <class T>
  inline void Manager::add_texture(const std::string& key,SDL_Surface* s, T& window){
    static_assert(std::is_pointer_v<T> || Util::is_smart_pointer_v<T>, "Error: window must be a (smart) pointer");
    if(haskey_texture(key)){
      LOGL("[Resource Manager]: texture {} already exists. Aborting",key);
      exit(EXIT_FAILURE);
    }
    _add(key,window->create_texture_from_surface(s));
    LOGL("[Resource Manager]: Added texture {}", key);
  }

  template <class T>
  inline void Manager::add_texture(const std::string& key, const std::filesystem::path& filename,T& window){
    static_assert(std::is_pointer_v<T> || Util::is_smart_pointer_v<T>, "Error: window must be a (smart) pointer");
    if(haskey_texture(key)){
      LOGL("[Resource Manager]: texture {} already exists. Aborting",key);
      exit(EXIT_FAILURE);
    }
    SDL_Surface* s = IMG_Load(filename.c_str());
    if( s==NULL){
      LOGL(SDL_GetError());
      exit(EXIT_FAILURE);
    }
    _add(key,window->create_texture_from_surface(s));
    SDL_FreeSurface(s);
    LOGL("[Resource Manager]: Added texture {}", key);
  }

  inline void Manager::replace_texture(const std::string& key, SDL_Texture* t){
    if(haskey_texture(key)){
      SDL_DestroyTexture(m_textures.at(key));
    }
    _add(key,t);
    LOGL("[Resource Manages]: Replaced texture {}", key);
  }

  template <class T>
  inline void Manager::replace_texture(const std::string& key, SDL_Surface* s, T& window){
    static_assert(std::is_pointer_v<T> || Util::is_smart_pointer_v<T>, "Error: window must be a (smart) pointer");
    if(haskey_texture(key)){
      SDL_DestroyTexture(m_textures.at(key));
    }
    _add(key,window->create_texture_from_surface(s));
    LOGL(SDL_GetError());
  }

  template <class T>
  inline void Manager::replace_texture(const std::string& key, const std::filesystem::path& filename, T& window){
    static_assert(std::is_pointer_v<T> || Util::is_smart_pointer_v<T>, "Error: window must be a (smart) pointer");
    SDL_Surface *s = IMG_Load(filename.c_str());
    if( s==NULL){
      LOGL(SDL_GetError());
      exit(EXIT_FAILURE);
    }
    _add(key,window->create_texture_from_surface(s));
    SDL_FreeSurface(s);
  }

}
